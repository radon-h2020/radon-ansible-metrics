{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the AnsibleMetrics documentation AnsibleMetrics is a Python-based static source code analyzer for Ansible blueprints that helps to quantify the characteristics of infrastructure code to support DevOps engineers when maintaining and evolving it. It currently supports 46 source code metrics, though other metrics can be derived by combining the implemented ones. It represents a step forward towards closing the gap for the implementation of software quality in-struments to support DevOps engineers when developing and maintaining infrastructure code and the development of measurement models for its quality! How to install Installation is made simple by the PyPI repository. Download the tool and install it with pip install ansiblemetrics . Alternatively, install it from the source code project directory with the following commands: pip install -r requirements.txt pip install . AnsibleMetrics is now installed and can be used from both command-line and Python code. How to use Command-line Run ansible-metrics --help for instructions about the usage: usage: ansible-metrics [-h] [--omit-zero-metrics] [-d DEST] [-o] [-v] src Extract metrics from Ansible scripts. positional arguments: src source file (playbook or tasks file) or directory optional arguments: -h, --help show this help message and exit --omit-zero-metrics omit metrics with value equal 0 -d DEST, --dest DEST destination path to save results -o, --output shows output -v, --version show program's version number and exit Assume that the following example is named playbook1.yml : --- - hosts: webservers vars: http_port: 80 remote_user: root tasks: - name: ensure apache is at the latest version yum: name: httpd state: latest - hosts: databases remote_user: root tasks: - name: ensure postgresql is at the latest version yum: name: postgresql state: latest - name: ensure that postgresql is started service: name: postgresql state: started and is located within the folder playbooks as follows: playbooks |- playbook1.yml |- playbook3.yml |- playbook3.yml Also, assume the user's working directory is the playbooks folder. Then, it is possible to extract source code characteristics from that blueprint by running the following command: ansible-metrics --omit-zero-metrics playbook1.yml --dest report.json For this example, the \\textit{report.json} will result in { \"filepath\": \"playbook1.yml\", \"avg_play_size\": 10, \"avg_task_size\": 4, \"lines_blank\": 4, \"lines_code\": 20, \"num_keys\": 20, \"num_parameters\": 6, \"num_plays\": 2, \"num_tasks\": 3, \"num_tokens\": 50, \"num_unique_names\": 3, \"num_vars\": 1, \"text_entropy\": 4.37 } Python AnsibleMetrics currently supports up to 46 source code metrics, implemented in Python. To extract the value for a given metric follow this pattern: from io import StringIO from ansiblemetrics.<general|playbook>.<metric> import <Metric> script = 'a valid yaml script' value = <Metric>(StringIO(script).count() where has to be replaced with the name of the desired metric module to compute the value of a specific metric. The difference between the general and the playbook modules lies in the fact that the playbook module contains metrics specific to playbooks (for example, the number of plays and tasks), while the general module contains metrics that can be generalized to other languages (for example, the lines of code). For example, to count the number of lines of code: from io import StringIO from ansiblemetrics.general.loc import LOC script = \"\"\" --- - hosts: all tasks: - name: This is a task! debug: msg: \"Hello World\" \"\"\" metric = LOC(StringIO(script)) print('Lines of executable code:', metric.count()) # This will result in # > Lines of executable code: 5 To extract the value for the 46 metrics at once, import the ansiblemetrics.metrics_extractor package and call the method extract_all() (in this case the return value will be a json object): from io import StringIO from ansiblemetrics.metrics_extractor import extract_all script = \"\"\" --- - hosts: all tasks: - name: This is a task! debug: msg: \"Hello World\" \"\"\" metrics = extract_all(StringIO(script)) print('Lines of executable code:', metrics['lines_code']) # This will result in # > Lines of executable code: 5 Below the list of the implemented metrics and their documentation. General Lines blank Lines of code Lines of comment Number of conditions Number of decisions Number of deprecated keywords Number of keys Number of math operations Number of suspicious comments Number of tokens Text entropy Playbook Average play size Average task size Number of blocks Number of block error handling Number of commands Number of deprecated modules Number of distinct modules Number of external modules Number of fact modules Number of fact modules Number of file extists Number of file mode Number of file modules Number of filters Number of ignore_error Number of import_playbook Number of import_role Number of import_tasks Number of include Number of include_role Number of include_tasks Number of include_vars Number of lookups Number of loops Number of name with variables Number of parameters Number of paths Number of plays Number of prompts Number of regex Number of roles Number of SSH Number of tasks Number of unique names Number of urls Number of variables","title":"Quick Start"},{"location":"#welcome-to-the-ansiblemetrics-documentation","text":"AnsibleMetrics is a Python-based static source code analyzer for Ansible blueprints that helps to quantify the characteristics of infrastructure code to support DevOps engineers when maintaining and evolving it. It currently supports 46 source code metrics, though other metrics can be derived by combining the implemented ones. It represents a step forward towards closing the gap for the implementation of software quality in-struments to support DevOps engineers when developing and maintaining infrastructure code and the development of measurement models for its quality!","title":"Welcome to the AnsibleMetrics documentation"},{"location":"#how-to-install","text":"Installation is made simple by the PyPI repository. Download the tool and install it with pip install ansiblemetrics . Alternatively, install it from the source code project directory with the following commands: pip install -r requirements.txt pip install . AnsibleMetrics is now installed and can be used from both command-line and Python code.","title":"How to install"},{"location":"#how-to-use","text":"","title":"How to use"},{"location":"#command-line","text":"Run ansible-metrics --help for instructions about the usage: usage: ansible-metrics [-h] [--omit-zero-metrics] [-d DEST] [-o] [-v] src Extract metrics from Ansible scripts. positional arguments: src source file (playbook or tasks file) or directory optional arguments: -h, --help show this help message and exit --omit-zero-metrics omit metrics with value equal 0 -d DEST, --dest DEST destination path to save results -o, --output shows output -v, --version show program's version number and exit Assume that the following example is named playbook1.yml : --- - hosts: webservers vars: http_port: 80 remote_user: root tasks: - name: ensure apache is at the latest version yum: name: httpd state: latest - hosts: databases remote_user: root tasks: - name: ensure postgresql is at the latest version yum: name: postgresql state: latest - name: ensure that postgresql is started service: name: postgresql state: started and is located within the folder playbooks as follows: playbooks |- playbook1.yml |- playbook3.yml |- playbook3.yml Also, assume the user's working directory is the playbooks folder. Then, it is possible to extract source code characteristics from that blueprint by running the following command: ansible-metrics --omit-zero-metrics playbook1.yml --dest report.json For this example, the \\textit{report.json} will result in { \"filepath\": \"playbook1.yml\", \"avg_play_size\": 10, \"avg_task_size\": 4, \"lines_blank\": 4, \"lines_code\": 20, \"num_keys\": 20, \"num_parameters\": 6, \"num_plays\": 2, \"num_tasks\": 3, \"num_tokens\": 50, \"num_unique_names\": 3, \"num_vars\": 1, \"text_entropy\": 4.37 }","title":"Command-line"},{"location":"#python","text":"AnsibleMetrics currently supports up to 46 source code metrics, implemented in Python. To extract the value for a given metric follow this pattern: from io import StringIO from ansiblemetrics.<general|playbook>.<metric> import <Metric> script = 'a valid yaml script' value = <Metric>(StringIO(script).count() where has to be replaced with the name of the desired metric module to compute the value of a specific metric. The difference between the general and the playbook modules lies in the fact that the playbook module contains metrics specific to playbooks (for example, the number of plays and tasks), while the general module contains metrics that can be generalized to other languages (for example, the lines of code). For example, to count the number of lines of code: from io import StringIO from ansiblemetrics.general.loc import LOC script = \"\"\" --- - hosts: all tasks: - name: This is a task! debug: msg: \"Hello World\" \"\"\" metric = LOC(StringIO(script)) print('Lines of executable code:', metric.count()) # This will result in # > Lines of executable code: 5 To extract the value for the 46 metrics at once, import the ansiblemetrics.metrics_extractor package and call the method extract_all() (in this case the return value will be a json object): from io import StringIO from ansiblemetrics.metrics_extractor import extract_all script = \"\"\" --- - hosts: all tasks: - name: This is a task! debug: msg: \"Hello World\" \"\"\" metrics = extract_all(StringIO(script)) print('Lines of executable code:', metrics['lines_code']) # This will result in # > Lines of executable code: 5 Below the list of the implemented metrics and their documentation.","title":"Python"},{"location":"#general","text":"Lines blank Lines of code Lines of comment Number of conditions Number of decisions Number of deprecated keywords Number of keys Number of math operations Number of suspicious comments Number of tokens Text entropy","title":"General"},{"location":"#playbook","text":"Average play size Average task size Number of blocks Number of block error handling Number of commands Number of deprecated modules Number of distinct modules Number of external modules Number of fact modules Number of fact modules Number of file extists Number of file mode Number of file modules Number of filters Number of ignore_error Number of import_playbook Number of import_role Number of import_tasks Number of include Number of include_role Number of include_tasks Number of include_vars Number of lookups Number of loops Number of name with variables Number of parameters Number of paths Number of plays Number of prompts Number of regex Number of roles Number of SSH Number of tasks Number of unique names Number of urls Number of variables","title":"Playbook"},{"location":"about/","text":"RADON-H2020 The RADON project aims to unlock the benefits that the European software industry can derive from serverless FaaS (function-as-a-service). The project team-members aim to create an upgraded framework for defining, developing and operating applications (DevOps) based on FaaS computing serverless technology. Find out more on https://radon-h2020.eu/","title":"About"},{"location":"about/#radon-h2020","text":"The RADON project aims to unlock the benefits that the European software industry can derive from serverless FaaS (function-as-a-service). The project team-members aim to create an upgraded framework for defining, developing and operating applications (DevOps) based on FaaS computing serverless technology. Find out more on https://radon-h2020.eu/","title":"RADON-H2020"}]}